<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hao&#39;s Blog</title>
    <link>https://rainjoe.github.io/</link>
    <description>Recent content on Hao&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 06 Jun 2021 12:40:33 +0800</lastBuildDate>
    
	<atom:link href="https://rainjoe.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Zookeeper</title>
      <link>https://rainjoe.github.io/post/zookeeper/</link>
      <pubDate>Sun, 06 Jun 2021 12:40:33 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/zookeeper/</guid>
      <description>ZooKeeper 是业界广泛使用的分布式协调服务，在服务发现，分布式配置管理，分布式锁等场景中广泛使用。这里根据6.824课程对其原理做一个简单的梳理。 线性</description>
    </item>
    
    <item>
      <title>了解 RabbitMQ </title>
      <link>https://rainjoe.github.io/post/rabbitmq_detail/</link>
      <pubDate>Sat, 15 May 2021 20:04:15 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/rabbitmq_detail/</guid>
      <description>如果只停留在如何使用 RabbitMQ 层面，根据官方教程了解一些基本的组件比如 Channel, Exchange, Queue 这几个组件的概念以及他们之间的关系基本可以应对大部分使用场景了。但是本着</description>
    </item>
    
    <item>
      <title>RabbitMQ &amp; Kafka</title>
      <link>https://rainjoe.github.io/post/rabbitmq_kafka/</link>
      <pubDate>Sun, 18 Apr 2021 19:40:03 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/rabbitmq_kafka/</guid>
      <description>RabbitMQ RabbitMQ 是什么 一个通用的消息代理中间件。 基于消息队列。 被设计为灵活的路由代理以及被动消费者模型。 为什么使用 RabbitMQ RabbitMQ 已经发展了很多年，成熟稳定。 多客户</description>
    </item>
    
    <item>
      <title>一致性哈希</title>
      <link>https://rainjoe.github.io/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</link>
      <pubDate>Sun, 04 Apr 2021 20:00:39 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</guid>
      <description>为什么需要一致性哈希 首先考虑一个普通的数据分区场景，例如分布式缓存，由于缓存很大，一台机器已经无法容纳这么多的缓存，这时就需要将缓存分散到不</description>
    </item>
    
    <item>
      <title>浅谈限流</title>
      <link>https://rainjoe.github.io/post/%E6%B5%85%E8%B0%88%E9%99%90%E6%B5%81/</link>
      <pubDate>Sat, 20 Mar 2021 20:49:45 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E6%B5%85%E8%B0%88%E9%99%90%E6%B5%81/</guid>
      <description>限流简介 通过限制服务速率来保护服务，保证尽自己最大能力服务。 限流可以针对 QPS /并发数/连接数/网络传输速率等。 固定速率限流 来看看 uber-go/ratelimit 的实现。 首先</description>
    </item>
    
    <item>
      <title>时间轮定时器</title>
      <link>https://rainjoe.github.io/post/%E6%97%B6%E9%97%B4%E8%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Tue, 02 Mar 2021 21:29:17 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E6%97%B6%E9%97%B4%E8%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>定时器 定时器可以在未来某个时间执行一个或多个任务。定时器的应用非常广泛比如模拟生活中的定时器，调度，流控，熔断，后台定时监控，超时控制等等。</description>
    </item>
    
    <item>
      <title>2020 年终总结</title>
      <link>https://rainjoe.github.io/post/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 27 Feb 2021 15:23:48 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>由于年底实在是太忙，又在准备面试，所以年终总结现在才写。这次主要是回顾一下 2020 年所做的一些事情，以及 2021 的计划，找找自身的不足以及努力的方向。 工</description>
    </item>
    
    <item>
      <title>Circular Buffer</title>
      <link>https://rainjoe.github.io/post/circular-buffer/</link>
      <pubDate>Sat, 19 Dec 2020 19:06:10 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/circular-buffer/</guid>
      <description>简介 队列在在各种各样的程序中广泛运用，队列虽然是比较简单的数据结构，但是非常灵活，有各种各样的实现，根据存储数据的底层结构不同可以分为数组和</description>
    </item>
    
    <item>
      <title>Bloom Filter 简介</title>
      <link>https://rainjoe.github.io/post/bloom-filter/</link>
      <pubDate>Sat, 21 Nov 2020 16:31:39 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/bloom-filter/</guid>
      <description>基本概念 Bloom Filter 是一个数据结构，它可以用来判断某个元素是否在集合内，具有运行快速，内存占用小的特点。 而高效插入和查询的代价就是，Bloom Filter 是一</description>
    </item>
    
    <item>
      <title>Consul 分布式锁实现</title>
      <link>https://rainjoe.github.io/post/consul-distributed-lock/</link>
      <pubDate>Sun, 15 Nov 2020 16:51:40 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/consul-distributed-lock/</guid>
      <description>分布式锁简介 什么是分布式锁 在单机环境中，为了防止多进程/多线程/多协程同时访问共享资源造成数据破坏，需要第三方提供一个互斥能力，这个时候可以</description>
    </item>
    
    <item>
      <title>CMU 15 445 PROJECT #3 QUERY EXECUTION</title>
      <link>https://rainjoe.github.io/post/cmu-15-445-project-3-query-execution/</link>
      <pubDate>Sat, 26 Sep 2020 18:11:31 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/cmu-15-445-project-3-query-execution/</guid>
      <description>概述 第三个实验是要我们实现sequential scans, inserts, hash joins, aggregations这几个执行器。因为现在还没有实现通过SQL生成执行计划这个功能</description>
    </item>
    
    <item>
      <title>了解 Go 内存分配</title>
      <link>https://rainjoe.github.io/post/%E4%BA%86%E8%A7%A3go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Tue, 08 Sep 2020 21:23:30 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E4%BA%86%E8%A7%A3go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>在工作中遇到线上服务内存问题时，通过pprof火焰图经常能看到一些运行时的函数，了解运行时的东西对分析线上服务出现的问题很有帮助。这篇文章主</description>
    </item>
    
    <item>
      <title>了解 Go 调度器</title>
      <link>https://rainjoe.github.io/post/%E4%BA%86%E8%A7%A3go%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Sun, 30 Aug 2020 15:47:37 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E4%BA%86%E8%A7%A3go%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description>无意中看到GopherCon上的一个演讲，The Scheduler Saga。觉得讲的很好，这篇文章作为笔记记录下来了。 Go 调度器初探 什么是 Go 调度器？ Go调度器</description>
    </item>
    
    <item>
      <title>CMU 15 445 PROJECT #2 HASH TABLE</title>
      <link>https://rainjoe.github.io/post/cmu-15-445-project-2-hash-table/</link>
      <pubDate>Sun, 12 Jul 2020 13:18:31 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/cmu-15-445-project-2-hash-table/</guid>
      <description>概述 这个实验是要实现一个采用开放寻址法的哈希表。哈希表必须通过第一个实验的 Buffer Pool 来操作磁盘页。哈希表包含 header page 和 block page 两部分。哈希表需要支持扩容。</description>
    </item>
    
    <item>
      <title>CMU 15-445 PROJECT #1 - BUFFER POOL</title>
      <link>https://rainjoe.github.io/post/cmu-15-445-project-1-buffer-pool/</link>
      <pubDate>Fri, 26 Jun 2020 15:21:20 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/cmu-15-445-project-1-buffer-pool/</guid>
      <description>概述 CMU 15-445 是 CMU 的一个操作系统课程，Youtube 上有整个课程的视频，视频早在过年的时候已经看完了，然而实验却迟迟没有动。去年给自己定了个任务是</description>
    </item>
    
    <item>
      <title>记一次线上微服务优化过程</title>
      <link>https://rainjoe.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 27 Mar 2020 21:51:20 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</guid>
      <description>最近由于新的技术经理发现我们线上的某个微服务经常在高峰期 OOM, 怀疑线上的微服务存在内存泄漏问题，于是找到我来一起排查这个 OOM 问题，因为我之前一直在</description>
    </item>
    
    <item>
      <title>k8s istio 微服务实践（下）</title>
      <link>https://rainjoe.github.io/post/k8s-istio-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8B-/</link>
      <pubDate>Sat, 07 Mar 2020 11:04:20 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/k8s-istio-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8B-/</guid>
      <description>上一部分通过 rancher 搭建了 k8s, 安装了 istio, 并且在 k8s 上部署了一个示例微服务，但是并没有将 istio 注入到微服务中，这部分我们将使用 istio 来治理微服务，主要包括通过 istio-ingressgateway 来</description>
    </item>
    
    <item>
      <title>k8s istio 微服务实践（上）</title>
      <link>https://rainjoe.github.io/post/k8s-istio-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8A/</link>
      <pubDate>Sun, 01 Mar 2020 17:01:20 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/k8s-istio-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8A/</guid>
      <description>随着云计算的日趋成熟，越来越多的企业将服务迁移到云，虚拟化，容器技术也飞速发展，出现了像 docker 这样的容器应用引擎，docker 的流行也使得容器编</description>
    </item>
    
    <item>
      <title>2019 年终总结</title>
      <link>https://rainjoe.github.io/post/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 05 Jan 2020 23:31:40 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>2019 年对我来说应该是做出改变的一年，最大的改变就是换了城市，换了工作，总体来说是达到了我原本的期望，但是并没有想象中的那么理想。 在上家公司的成</description>
    </item>
    
    <item>
      <title>6.828 lab6 Network Driver</title>
      <link>https://rainjoe.github.io/post/lab-6_-network-driver/</link>
      <pubDate>Sun, 11 Aug 2019 19:15:14 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/lab-6_-network-driver/</guid>
      <description>Exercise 1 在每一次时钟中断时调用 time_tick, 实现 sys_time_msec 系统调用 Exercise 2 阅读 Software Developer&amp;rsquo;s Manual，了解 e1000 Exercise 3 实现一个连接函数来初始化 e1000, 在 pci_attach_vendor 中增加一项，使得一旦发现了 pci 设备</description>
    </item>
    
    <item>
      <title>6.828 lab5 File system, Spawn and Shell</title>
      <link>https://rainjoe.github.io/post/lab-5_-file-system-spawn-and-shell/</link>
      <pubDate>Wed, 07 Aug 2019 22:45:14 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/lab-5_-file-system-spawn-and-shell/</guid>
      <description>Exercise 1 i385_init 通过给 env_create 传递 ENV_TYPE_FS 类型参数来标识文件系统环境，修改 env_create 使得文件系统环境拥有 I/O 权限，IO 权限由 EFLAGS 寄存器的 IOPL 位设定 Question 1 你需要做什么来保证环境切换</description>
    </item>
    
    <item>
      <title>6.828 lab4 Preemptive Multitasking</title>
      <link>https://rainjoe.github.io/post/lab-4_-preemptive-multitasking/</link>
      <pubDate>Sat, 03 Aug 2019 20:33:27 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/lab-4_-preemptive-multitasking/</guid>
      <description>Part A: Multiprocessor Support and Cooperative Multitasking Exercise 1 实现 mmio_map_region MMIO 区域的基地址为 MMIOBASE，我们要将 [pa, pa+size] 映射到 [MMIOBASE, MMIOBASE+size]，因为这里是 device memory 所以 cache 不可用，可以</description>
    </item>
    
    <item>
      <title>6.828 lab3 User Environments</title>
      <link>https://rainjoe.github.io/post/lab-3_-user-environments/</link>
      <pubDate>Thu, 25 Jul 2019 23:19:14 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/lab-3_-user-environments/</guid>
      <description>Part A: User Environments and Exception Handling Exercise 1 修改 kern/pmap.c 中的 mem_init()，分配存放 env 数组的内存，并且完成内存空间映射 代码实现： Exercise 2 实现下列函数 env_init(): 初始胡 env 数组，将数组</description>
    </item>
    
    <item>
      <title>6.828 lab2 Memory Management</title>
      <link>https://rainjoe.github.io/post/lab-2_-memory-management/</link>
      <pubDate>Sat, 13 Jul 2019 19:55:34 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/lab-2_-memory-management/</guid>
      <description>Part 1: Physical Page Management Exercise 1 实现 kern/pmap.c 中的下列四个函数 boot_alloc() mem_init() page_init() page_alloc() page_free() 首先实现 boot_alloc(), 根据注释，实现三点 如果 n &amp;gt; 0 分配 n 个字节的物理内存，不需要初始化 如果 n = 0 直接将下个</description>
    </item>
    
    <item>
      <title>6.828 lab1 Booting a PC</title>
      <link>https://rainjoe.github.io/post/lab1_-booting-a-pc/</link>
      <pubDate>Thu, 11 Jul 2019 21:47:54 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/lab1_-booting-a-pc/</guid>
      <description>Part 1: PC Bootstrap Exercise 1 通过 PC Assembly Language Book 了解汇编语言，不需要现在就去读这些，但是要在读写 x86 汇编时知道去查阅这些资料。 建议阅读 Brennan&amp;rsquo;s Guide to Inline Assembly 了解 AT&amp;amp;T 汇编语法，因为 Jos</description>
    </item>
    
    <item>
      <title>6.824 lab4 Sharded Key/Value Service</title>
      <link>https://rainjoe.github.io/post/6.824-lab4-sharded-key-value-service/</link>
      <pubDate>Sun, 21 Apr 2019 23:09:34 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/6.824-lab4-sharded-key-value-service/</guid>
      <description>这个 lab 是要在 lab2 的基础上实现一个容错的 kv 存储 (kvserver)，实现 Put、Append、Get 操作。 3A 首先 client 端发起的 Put、Append、</description>
    </item>
    
    <item>
      <title>6.824 lab3 Fault-tolerant Key/Value Service</title>
      <link>https://rainjoe.github.io/post/6.824-lab3-fault-toleran-key-value-service/</link>
      <pubDate>Sun, 13 Jan 2019 23:06:36 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/6.824-lab3-fault-toleran-key-value-service/</guid>
      <description>这个 lab 是要在 lab2 的基础上实现一个容错的 kv 存储 (kvserver)，实现 Put、Append、Get 操作。 3A 首先 client 端发起的 Put、Append、</description>
    </item>
    
    <item>
      <title>2018 年终总结</title>
      <link>https://rainjoe.github.io/post/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 31 Dec 2018 23:01:40 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>考研与找工作 转眼间一年过去了，回想去年的此刻，我还在学校自习室里为考研奋斗，梦想着能考上研究生，摆脱我不感兴趣的复合材料专业，投入到码农的大</description>
    </item>
    
    <item>
      <title>6.824 lab2 raft</title>
      <link>https://rainjoe.github.io/post/6.824-lab2-raft/</link>
      <pubDate>Wed, 28 Nov 2018 22:49:54 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/6.824-lab2-raft/</guid>
      <description>在 lab2 实在是拖的太久了，今天终于通过了所有测试用例，先附上一张测试全部通过的截图。 说实话，做这个lab还是蛮吃力的，之前对并发编程接触的不多，</description>
    </item>
    
    <item>
      <title>6.824 lab1 mapreduce</title>
      <link>https://rainjoe.github.io/post/6.824-lab1-mapreduce/</link>
      <pubDate>Thu, 11 Oct 2018 22:49:54 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/6.824-lab1-mapreduce/</guid>
      <description>这个 lab 很早之前就已经做过了，最近在填raft的坑，就干脆把这个也重新做了一下。总的来说这个lab还算是简单的，当然还是有些实现细节要注意。 Part</description>
    </item>
    
    <item>
      <title>最近工作的一些感悟</title>
      <link>https://rainjoe.github.io/post/%E6%9C%80%E8%BF%91%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/</link>
      <pubDate>Mon, 01 Oct 2018 22:44:02 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E6%9C%80%E8%BF%91%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/</guid>
      <description>突然发现有好几个月没写博客了。做这个博客的初衷是记录我的技术成长之路，当然也是为了找工作面试的时候能作为加分项。听过来人说，电脑一旦从爱好变</description>
    </item>
    
    <item>
      <title>豆瓣异步爬虫</title>
      <link>https://rainjoe.github.io/post/%E8%B1%86%E7%93%A3%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/</link>
      <pubDate>Thu, 15 Feb 2018 21:39:22 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E8%B1%86%E7%93%A3%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/</guid>
      <description>对于爬虫来说，首先要能够根据自身目的准确抓取自己想要的数据，其次要保证高效，对于网络数据获取这种情景而言，网络** IO 是最大的性能瓶颈，而异步</description>
    </item>
    
    <item>
      <title>位运算</title>
      <link>https://rainjoe.github.io/post/%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Mon, 22 Jan 2018 17:14:49 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>位操作是程序设计中对位模式按位或二进制数的一元和二元操作。 位运算操作符 基本的位操作符有与、或、异或、取反、左移、右移这 6 种，它们的运算规则如</description>
    </item>
    
    <item>
      <title>Python 中的并行编程</title>
      <link>https://rainjoe.github.io/post/python%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 20 Oct 2017 19:30:48 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/python%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</guid>
      <description>Python 支持多进程，多线程，以及协程，但是有 GIL 全局锁的限制，Python 只能运行一个系统级线程，无法利用多核 CPU。所以 Python 中的多线程，协程只适合 IO</description>
    </item>
    
    <item>
      <title>操作系统之进程与线程</title>
      <link>https://rainjoe.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Thu, 21 Sep 2017 20:11:14 +0800</pubDate>
      
      <guid>https://rainjoe.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>现代操作系统可以在同一时间做不同的事情，比如一边浏览网页，一边听音乐，这就是因为实现了多进程或者是多线程，在单核 CPU 中，CPU 在不同进程中来回</description>
    </item>
    
  </channel>
</rss>